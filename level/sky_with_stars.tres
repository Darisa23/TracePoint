[gd_resource type="Shader" format=3 uid="uid://cdlt3ujrpad32"]

[resource]
code = "shader_type sky;

// Textura de fondo
uniform sampler2D skyTexture;

// Colores de respaldo si no hay textura
uniform vec3 skyColor : source_color = vec3(1.0, 1.0, 1.0);
uniform vec3 horizonColor : source_color = vec3(0.9, 0.9, 0.9);

// Parámetros de partículas
uniform float particle_speed = 0.5;
uniform float particle_density = 50.0;
uniform float particle_size = 0.02;
uniform vec3 neon_blue : source_color = vec3(0.4, 0.8, 1.0);
uniform float glow_intensity = 2.0;

// Función de ruido hash
float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

// Función para generar partículas
float particles(vec2 uv, float time) {
    float particle_field = 0.0;
    
    // Crear múltiples capas de partículas
    for (float i = 0.0; i < particle_density; i++) {
        vec2 seed = vec2(i * 0.1, i * 0.2);
        
        // Posición inicial de la partícula
        float x = hash(seed);
        float y = hash(seed + vec2(1.0, 2.0));
        
        // Velocidad individual de cada partícula
        float speed = hash(seed + vec2(3.0, 4.0)) * 0.5 + 0.5;
        
        // Movimiento de las partículas
        vec2 particle_pos = vec2(x, y);
        particle_pos.y = fract(particle_pos.y - time * particle_speed * speed);
        particle_pos.x += sin(time * speed + i) * 0.1;
        
        // Distancia a la partícula
        float dist = distance(uv, particle_pos);
        
        // Tamaño variable para cada partícula
        float size = particle_size * (0.5 + hash(seed + vec2(5.0, 6.0)) * 0.5);
        
        // Crear el brillo de la partícula
        float particle = smoothstep(size, size * 0.3, dist);
        particle += smoothstep(size * 2.0, size * 0.5, dist) * 0.3;
        
        particle_field += particle;
    }
    
    return particle_field;
}

void sky() {
    // Obtener color del fondo (textura o degradado)
    vec3 color = texture(skyTexture, SKY_COORDS).rgb;
    
    // Si no hay textura, usar degradado
    if (color == vec3(0.0)) {
        float col = clamp(EYEDIR.y / 0.05, 0.0, 1.0);
        color = mix(horizonColor, skyColor, col);
    }
    
    // Agregar partículas azul neón usando SKY_COORDS
    float particle_field = particles(SKY_COORDS, TIME);
    
    // Color neón con brillo
    vec3 particle_color = neon_blue * glow_intensity;
    
    // Mezclar partículas con el fondo
    color = mix(color, particle_color, clamp(particle_field, 0.0, 1.0));
    
    // Agregar un brillo adicional alrededor de las partículas
    color += particle_color * particle_field * 0.5;
   	COLOR = color;
}"
