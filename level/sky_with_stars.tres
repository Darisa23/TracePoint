[gd_resource type="Shader" format=3 uid="uid://cdlt3ujrpad32"]

[resource]
code = "shader_type sky;
// Textura de fondo
uniform sampler2D skyTexture : filter_linear, repeat_enable;
// Colores de respaldo si no hay textura
uniform vec3 skyColor : source_color = vec3(1.0, 1.0, 1.0);
uniform vec3 horizonColor : source_color = vec3(0.9, 0.9, 0.9);
// Filtro de color para la textura
uniform vec3 texture_tint : source_color = vec3(1.0, 1.0, 1.0);
uniform float tint_intensity : hint_range(0.0, 1.0) = 0.85;
// Parámetros de partículas
uniform float particle_speed = 0.5;
uniform float particle_density = 50.0;
uniform float particle_size = 0.02;
uniform vec3 neon_blue : source_color = vec3(0.4, 0.8, 1.0);
uniform float glow_intensity = 2.0;

// Función de ruido hash
float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

// Función para generar partículas
float particles(vec3 direction, float time) {
    vec2 uv = vec2(
        atan(direction.x, direction.z) / (3.14159265 * 2.0) + 0.5,
        acos(direction.y) / 3.14159265
    );
    
    float particle_field = 0.0;
    
    for (float i = 0.0; i < particle_density; i++) {
        vec2 seed = vec2(i * 0.1, i * 0.2);
        
        float x = hash(seed);
        float y = hash(seed + vec2(1.0, 2.0));
        float speed = hash(seed + vec2(3.0, 4.0)) * 0.5 + 0.5;
        
        vec2 particle_pos = vec2(x, y);
        particle_pos.y = fract(particle_pos.y - time * particle_speed * speed);
        particle_pos.x += sin(time * speed + i) * 0.1;
        
        float dx = abs(uv.x - particle_pos.x);
        dx = min(dx, 1.0 - dx);
        
        float dy = abs(uv.y - particle_pos.y);
        float dist = sqrt(dx * dx + dy * dy);
        
        float size = particle_size * (0.5 + hash(seed + vec2(5.0, 6.0)) * 0.5);
        
        float particle = smoothstep(size, size * 0.3, dist);
        particle += smoothstep(size * 2.0, size * 0.5, dist) * 0.3;
        
        particle_field += particle;
    }
    
    return particle_field;
}

void sky() {
    // Obtener color del fondo desde la textura
    vec3 color = texture(skyTexture, SKY_COORDS).rgb;
    
    // Si hay textura, aplicar filtro de color FUERTE
    if (length(color) > 0.01) {
        // Convertir a escala de grises primero
        float luminance = dot(color, vec3(0.299, 0.587, 0.114));
        
        // Aplicar el tint basado en la luminosidad
        vec3 tinted = texture_tint * luminance * 2.0;
        
        // Mezclar con intensidad alta
        color = mix(color, tinted, tint_intensity);
        
        // Añadir una capa extra de color
        color += texture_tint * 0.15;
    } else {
        // Si no hay textura, usar degradado
        float col = clamp(EYEDIR.y / 0.05, 0.0, 1.0);
        color = mix(horizonColor, skyColor, col);
    }
    
    // Agregar partículas azul neón
    float particle_field = particles(EYEDIR, TIME);
    
    // Color neón con brillo
    vec3 particle_color = neon_blue * glow_intensity;
    
    // Mezclar partículas con el fondo
    color = mix(color, particle_color, clamp(particle_field, 0.0, 1.0));
    
    // Agregar un brillo adicional alrededor de las partículas
    color += particle_color * particle_field * 0.5;
    
    COLOR = color;
}"
